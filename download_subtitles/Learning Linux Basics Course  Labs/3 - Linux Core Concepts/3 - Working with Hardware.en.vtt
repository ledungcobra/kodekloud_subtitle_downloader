WEBVTT

1
00:00:00.820 --> 00:00:07.020
In this section, we will look at how Linux identifies and manages hardware devices attached to the system.

2
00:00:07.560 --> 00:00:13.480
Then, we will see ways to list and get detailed information about these devices from the command line.

3
00:00:14.460 --> 00:00:19.720
To understand this, let's take an example of a USB disk to be used in the system.

4
00:00:20.280 --> 00:00:24.960
As soon as the device is attached to the system, a corresponding device driver,

5
00:00:25.500 --> 00:00:30.400
which is part of the kernel space, detects the stage change, and generates an event.

6
00:00:31.240 --> 00:00:38.960
This event, which is called uevent is then sent to the user-space device manager daemon called udev.

7
00:00:39.460 --> 00:00:44.260
The udev service is then responsible for dynamically creating a device node

8
00:00:44.260 --> 00:00:49.260
associated with the newly attached drive in the /dev file system.

9
00:00:50.580 --> 00:00:56.940
Once this process is complete, the newly attached disk should be visible under /dev file system.

10
00:01:00.200 --> 00:01:07.160
Now let's check out a few ways to list and get detailed information about the hardware components attached to the Linux system.

11
00:01:08.480 --> 00:01:14.140
Dmesg is a tool used to display messages from an area of the kernel called the ring buffer.

12
00:01:15.220 --> 00:01:22.120
When a Linux operating system boots up, there are numerous messages generated by the kernel that appear on the display screen.

13
00:01:23.040 --> 00:01:28.240
These messages also contain logs from the hardware devices that the kernel detects

14
00:01:28.520 --> 00:01:32.160
and provide a good indication of whether it is able to configure them.

15
00:01:33.040 --> 00:01:39.240
You can redirect the output of dmesg using less or search for specific keywords using grep.

16
00:01:42.460 --> 00:01:46.960
The udevadm utility is a management tool for udev.

17
00:01:47.700 --> 00:01:53.480
The udevadm info command queries the udev database for device information.

18
00:01:54.380 --> 00:01:58.320
In the example, we are querying the hard disk attached to the system.

19
00:01:59.280 --> 00:02:03.760
The udevadm monitor command listens to the kernel uevents.

20
00:02:04.500 --> 00:02:07.660
Upon detecting an event, it prints the details,

21
00:02:07.900 --> 00:02:11.300
such as the device path and device name on the screen.

22
00:02:12.260 --> 00:02:17.920
This command is quite handy to determine the details of a newly attached or removed device.

23
00:02:18.900 --> 00:02:22.860
In the example here, we have removed the USB mouse from the system.

24
00:02:25.900 --> 00:02:30.360
The lspci command stands for list PCI.

25
00:02:31.040 --> 00:02:37.120
This command is used to display information about all PCI devices that are configured in the system.

26
00:02:38.080 --> 00:02:44.660
Examples of PCI devices are ethernet cards, raid controllers, video cards,

27
00:02:44.960 --> 00:02:50.380
and wireless adapters that directly attach to PCI slots in the motherboard of the computer.

28
00:02:51.480 --> 00:02:55.760
PCI is an abbreviation for peripheral component interconnect.

29
00:02:59.300 --> 00:03:04.120
The lsblk command lists information about block devices.

30
00:03:04.920 --> 00:03:07.140
Here sda is the physical disk.

31
00:03:07.580 --> 00:03:12.740
The sda1 to sda5 are partitions created for this disk.

32
00:03:13.380 --> 00:03:17.020
We will learn more about disks and partitions in the storage section.

33
00:03:17.960 --> 00:03:22.580
For now, please remember that the type disk refers to the whole physical disk,

34
00:03:23.080 --> 00:03:28.660
and the type partition refers to a reusable disk space carved out of the physical disk.

35
00:03:29.440 --> 00:03:35.820
In the command output, you can also see that there are major and minor numbers associated with each device.

36
00:03:36.740 --> 00:03:40.080
The major number which is on the left-hand side of the colon

37
00:03:40.280 --> 00:03:44.200
identifies the type of device driver associated with the device.

38
00:03:44.820 --> 00:03:49.000
In this case, the number 8 refers to a block sdisk device.

39
00:03:49.640 --> 00:03:55.740
The minor number is used to differentiate amongst devices that are similar and share the same major number.

40
00:03:56.720 --> 00:04:02.540
Here the numbers 0 to 5, help identify the different partitions for the disk sda.

41
00:04:03.680 --> 00:04:08.920
The table here shows some of the commonly used devices along with their major numbers.

42
00:04:09.520 --> 00:04:12.740
For a comprehensive list, check out the reference article.

43
00:04:16.600 --> 00:04:22.940
To display information about the CPU architecture, use the lscpu command.

44
00:04:23.660 --> 00:04:28.240
This command provides detailed information such as the CPU architectures,

45
00:04:28.700 --> 00:04:32.340
the number of cores, threads, model, et cetera.

46
00:04:33.340 --> 00:04:39.620
To understand this output better, let us quickly go through the two popular CPU architecture types

47
00:04:40.260 --> 00:04:43.500
32-bit and 64-bit processors

48
00:04:44.620 --> 00:04:48.980
32-bit processors were predominantly used until the 1990s.

49
00:04:49.620 --> 00:04:57.280
In simple terms, a 32-bit CPU can address and store 2 to the power of 32 values in its registers.

50
00:04:58.380 --> 00:05:02.680
A register is a location on the CPU that can be rapidly accessed.

51
00:05:03.280 --> 00:05:08.520
It is generally used to load data from memory and carry out arithmetic operations.

52
00:05:09.520 --> 00:05:16.840
In comparison, the 64-bit CPU can address and store 2 to the power of 64 values.

53
00:05:17.540 --> 00:05:22.740
The 32-bit CPU also has a limitation on maximum memory of 4 gigabytes,

54
00:05:23.400 --> 00:05:28.920
whereas for a 64-bit CPU, the theoretical limit is 18 exabytes.

55
00:05:29.700 --> 00:05:33.080
This number is often limited by the operating system used.

56
00:05:33.880 --> 00:05:39.340
With these differences in architecture also comes the limitation of software running on them.

57
00:05:40.040 --> 00:05:46.580
For example, a machine with a 32-bit CPU architecture can only run a 32-bit OS.

58
00:05:47.200 --> 00:05:52.280
You cannot install a 64-bit OS in a 32-bit CPU machine,

59
00:05:52.840 --> 00:05:56.420
but the other way around is still possible, although not recommended.

60
00:05:57.140 --> 00:06:00.420
The same is applicable for software running on these machines.

61
00:06:00.980 --> 00:06:06.720
A 32-bits CPU machine can only install a 32-bit version of a software,

62
00:06:07.400 --> 00:06:13.460
a 64-bit CPU can run both 32-bit and 64-bit software.

63
00:06:14.160 --> 00:06:19.980
Still, it is generally recommended to run the 64-bit version if such an option is available.

64
00:06:23.300 --> 00:06:28.420
Now, going back to the lscpu command and briefly inspect the output,

65
00:06:29.580 --> 00:06:34.080
the first thing to notice is that the CPU architecture is 64-bit.

66
00:06:34.980 --> 00:06:40.080
Sockets are the physical slots on the motherboard where you can insert a physical CPU.

67
00:06:40.600 --> 00:06:42.440
In this case, it is 1.

68
00:06:43.520 --> 00:06:49.800
Each physical CPU can have multiple cores, and in this case, the number of cores is 4

69
00:06:50.640 --> 00:06:55.740
and each core can run multiple threads at the same time, in this case, 2.

70
00:06:56.620 --> 00:07:02.320
The total number of CPU or virtual CPUs rather available on the system

71
00:07:02.680 --> 00:07:08.820
is the number of sockets multiplied by the number of cores and threads, which is 8 in this case.

72
00:07:09.680 --> 00:07:13.020
This system can run 8 parallel threads at a time,

73
00:07:13.560 --> 00:07:17.560
and this value is seen under the CPU's field in the command output.

74
00:07:18.860 --> 00:07:25.820
Moving along, the command also prints other useful information, such as the vendor and model of the CPU.

75
00:07:29.380 --> 00:07:34.400
The lsmem command can be used to list the available memory in the system.

76
00:07:34.800 --> 00:07:39.220
Use this command with the dash dash summary flag to print the summary.

77
00:07:40.120 --> 00:07:44.200
In this case, this machine has 8 gigabytes of online memory.

78
00:07:45.500 --> 00:07:51.820
To get a more comprehensive output, run the lsmem command without the dash summary flag.

79
00:07:52.700 --> 00:07:56.980
Another command to see information about the memory is the free command.

80
00:07:57.580 --> 00:08:01.440
This command shows the total versus used memory in the system.

81
00:08:02.580 --> 00:08:06.300
Use the dash m flag to display the result in MB,

82
00:08:06.800 --> 00:08:10.960
the dash k in KB, and dash g in GB.

83
00:08:14.160 --> 00:08:21.220
The lshw is a tool to extract detailed information on the entire hardware configuration of the machine.

84
00:08:22.120 --> 00:08:28.020
It can report exact memory configuration, firmware version, mainboard configuration,

85
00:08:28.360 --> 00:08:33.940
CPU version and speed, cache configuration, bus speed, et cetera.

86
00:08:35.000 --> 00:08:40.240
Bob tries to run the command lshw and gets a warning message that says

87
00:08:40.240 --> 00:08:45.260
the output is incomplete or inaccurate and to run it as the superuser.

88
00:08:46.160 --> 00:08:50.860
He shows that to Dave, Dave replies, "Yes.

89
00:08:51.340 --> 00:08:55.440
The more you work on the system, you will find that there are many commands

90
00:08:55.440 --> 00:08:59.160
that require root user privileges to work correctly."

91
00:08:59.980 --> 00:09:04.840
We will cover privilege escalation in detail some other day, but for now,

92
00:09:05.120 --> 00:09:08.700
let me show you how you can run commands with root privileges.

93
00:09:09.540 --> 00:09:15.060
Dave explains that not every user can run all the commands in the Linux system.

94
00:09:15.620 --> 00:09:19.080
Some commands need to be run as the root or the superuser.

95
00:09:19.960 --> 00:09:24.380
Fortunately, there is an easy way to do this with the command called sudo.

96
00:09:25.280 --> 00:09:32.860
Try running the same command as before, but this time, add the command sudo before the lshw command.

97
00:09:34.360 --> 00:09:38.060
Bob tries it, finds that it is asking for his password.

98
00:09:39.040 --> 00:09:45.140
Dave continues, "With sudo, users are prompted to enter their own password."

99
00:09:46.100 --> 00:09:52.860
Bob enters the password and this time the result of lshw command is printed without any warning.

100
00:09:54.100 --> 00:10:00.760
Dave carries on, "With sudo, you can control which user gets to run commands as the superuser.

101
00:10:01.360 --> 00:10:08.520
You can also define which commands they can run, and also replay back commands a user has run with root privileges."

102
00:10:09.260 --> 00:10:12.580
We will cover sudo in much more detail in a later session.
